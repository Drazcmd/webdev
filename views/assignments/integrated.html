<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/google/code-prettify/master/src/prettify.css">
<style>
code, pre {
    font-size: 0.85em;
}
</style>

<div onload="prettyPrint()">

<p>
In this assignment you will integrate your frontend and backend web applications.
</p>

<h2>Stubbing the Backend</h2>
<p>
There are technically two stages in the integration process.  The first stage is to point the
frontend at the backend instead of the dummy server.  The backend currently has only two
endpoints implemented, which means the other endpoints will be broken.  Therefore the first
stage includes implementation of these endpoints with stubs.  A stub returns dummy data
</p>
<pre class="prettyprint lang-javascript">
// this is user.js which contains all user profile information except passwords
exports.setup = function(app) {
    app.get('/statuses/:users*?', isLoggedIn, getStatuses)
}

function getStatuses(req, res) {
    res.send({ statuses: [ 
        { username: 'user', status: 'the status of the user' } 
    ] })
}
</pre>
<p>Note that we're using the <code>isLoggedIn</code> middleware to assure that all requests 
are made by authenticated clients.  The API for the endpoints is the same as for the dummy
server (i.e., this way we don't need to change any of the frontend code).  That api is found here
</p>
<center><a target="_blank" href="data/api.html">Backend API list of endpoints</a></center>
<p>
Making stubs for all of the endpoints should not take too long.  If we were doing TDD then
we would write tests for each function before we even write the stubs.  Given that you just
got a good experience in writing tests, I recommend you do this, but it will not be a requirement
for this assignment.  Additionally, we already have a working frontend with end-to-end tests 
which can serve us well in testing our backend functionality.  (But again, unit testing the 
backend is the preferred approach.)
</p>

<h3>Cross-Origin Resource Sharing</h3>
<p>The frontend and backend have different origins.  When running locally you might have the 
frontend running through the python server on port 8080 and the backend served up on port 8000 or 3333 or whatever you like.
Therefore we need to enable CORS for the AJAX calls to complete.  See lecture 23 for the inclass exercise for enabling CORS.
</p>

<h2>Implementing the Backend</h2>

<p>Users must be authenticated to use the backend.  They authenticate by suppling their
username and password in a payload to <code>POST /login</code> which if successfully
authenticated will return a cookie.  The cookie will be passed on all subsequent requests
until the cookie expires or the user <code>PUT /logout</code> which deletes the cookie.</p>

<h3>Database Setup</h3>

<p>We need a database to store user information.  Because we are developing a MEAN stack,
we will use MongoDB for our document store.  Heroku provides an easy prescription for 
setting up a mongolab mongoDB for your backend app.  See a 
<a href="https://piazza.com/class/ibpbmkjtg5e3m8?cid=219" target="_blank">piazza post</a>
for instructions on setting up a mongolab mongoDB directly.  To connect to your mongoDB
from your locally running application, you will need the mongodb url.  If you setup 
your db from Heroku you can get the url from the Heroku configuration
</p>
<pre class="prettyprint lang-bash">
heroku config | grep MONGO
</pre>
<p>if you setup through mongolab, then they provided you a URL.  You can if you want
to hardcode the URL in your code.  However, this breaks separations of concerns: configuration should not be in code.
Instead we want to use environment variables.  To set it on heroku
<pre class="prettyprint lang-bash">
heroku config:set MONGOLAB_URI=&lt;the url from mongolab&gt;
</pre>
<p>When running locally you can store your environment variables in a local file and then load them in node.
Here are two different ways of doing it.</p>
<pre class="prettyprint lang-javascript">
// this is .env
MONGO_URL="mongodb://ian:sekret@widmore.mongohq.com:27017/dev_local"
REDIS_KEY="1234"

// runs these in terminal
# npm install dotenv --save-dev
# echo .env >> .gitignore

// add this to index.js
if (process.env.NODE_ENV !== "production") {
    require('dotenv').load()
}
</pre>
or
<pre class="prettyprint lang-javascript">
// this is .env.json
{
  "MONGO_URL": "mongodb://ian:sekret@widmore.mongohq.com:27017/dev_local",
  "REDIS_KEY": "1234"
}

// runs these in terminal
# npm install dot-env --save-dev
# echo .env.json >> .gitignore

// add this to index.js
if (process.env.NODE_ENV !== "production") {
    require('dot-env')
}
</pre>
<p>So either store your environment in a shell file or in a json file -- your pick.
In both cases we save the loading module in our dev dependencies (so they don't show up on Heroku)
and ignore the environment file (so it doesn't show up on Heroku).  Put the loading logic
in your <code>index.js</code> file so it will be loaded first on startup.
</p>

<h3>Database Collections</h3>

<p>In the databse we will have at least three collections: users, posts, profiles. 
If we were using a RDBMS or ODM (e.g., mongoose) then these are what the schemas might look like
</p>
<pre class="prettyprint lang-javascript">
users {
    username: String,
    salt: String,
    hash: String
}

profiles {
    username: String,
    status: String,
    following: [ String ],
    email: String,
    zipcode: String,
    picture: String
}

posts {
    id: Number,
    author: String,
    body: String,
    date: Date,
    img: String, 
    comments: [{
        commentId: Number,
        author: String,
        body: String,
        date: Date
    }]
}
</pre>
<p>If you use mongoose, then you would call these schemas by their singular name: user, profile, post. 
I would therefore have in my <code>model.js</code> file</p>
<pre class="prettyprint lang-javascript">
// this is model.js
var mongoose = require('mongoose')

var userSchema = new mongoose.Schema({
    ...
})

exports.User = mongoose.model('users', userSchema)
</pre>
<p>and then in auth.js I would have</p>
<pre class="prettyprint lang-javascript">
// this is in auth.js
var models = require('./model.js')

models.User.find({ username: "sep1" }).exec(function(err, users) {
    ...
})
</pre>
<p>If you're not using mongoose (which is 100% okay) then you'd have something like this</p>
<pre class="prettyprint lang-javascript">
// this is in auth.js
db.collection('users').find({ username: "sep1" }).toArray(function(err, users) {
    ...
})
</pre>
<p>and there may or may not be a <code>model.js</code> file depending on where you put your logic (remember divide and conquer).</p>

<p>Implement the logic to query the database for the <code>GET</code> endpoints, and write to the database for the <code>PUT</code> and <code>POST</code> endpoints.
The default implementation of mongoDB collections have an <code>_id</code> field.  The _id is <u>automatically</u> populated
for you during inserts.  
<pre>
_id: ObjectId("5099803df3f4948bd2f98391")
</pre>
<p>you can use this instead of a numeric id supplied by your server.  I.e., just omit "id" from your schema and perform
queries on _id instead.  That means a request for a specific post might be</p>
<pre>
GET /posts/5099803df3f4948bd2f98391
</pre>
<p>instead of <code>GET /posts/1234</code> which is perfectly fine.  </p>
<p>
For the commentId you get to choose what to do.  A "global" value probably is not a good idea because
it may collide across different servers.  Instead you might consider something unique, such as the hash of the author &amp; timestamp which assumes that an individual user will only be connected to one server and making one post at a time -- which I think is a reasonable assumption to make.  The commentId therefore is a String not a number.  Again, it doesn't matter what it is, it is just for us to use when looking up and identifying a particular comment.</p>

<h3>Authentication</h3>

<p>We will use salted passwords for our authentication.  For this assignment we will
implement the salting and hashing ourselves.  In class #22 we added the <code>POST /login</code>
and <code>POST /register</code> endpoints.</p>
<p>
Register will add to the database a new document
with a username, a randomly created salt, and the hash of the user's salted password.
The salt is a random string, perhaps a combination of the user's username and the current time.
We can use <code>md5</code> hashing here or if you prefer you can use <code>bcrypt</code> which
is a popular encryption library.  (For either use npm install --save).
</p><p>
A new user will have a blank profile picture (you could supply some default pic if you like) and should have some default status message.
</p><p>
Login will accept from the user their username and password.  Get the user document from the database
for the username which contains the salt and hash.  Salt the password and compare the hashes.  If they
match then create a session for the user.  Store the session in a map from session key to user document.
Here is an example that attempts to create unique session keys for users
</p>
<pre class="prettyprint lang-javascript">
// this is in auth.js
var sessionUser = {}

// security by obscurity we don't want people guessing a sessionkey
var sessionKey = md5(mySecretMessage + new Date().getTime() + userObj.username)
sessionUser[sessionKey] = userObj
res.cookie('sid', sessionKey, { maxAge: 3600*1000, httpOnly: true})
</pre>
<p>we store the session key in a cookie for the user.  Note that the sessionUser
map really should be a least recently used map, otherwise it is a potential memory hog.</p>
<p>When a user logs out, remove their sessionKey form the sessionUser map and clear the cookie.</p>

<h3>A User's Feed</h3>

<p>Each logged in user has a feed which is the collection of their posts and their followers posts.  
When the user requests <code>GET /posts</code> we therefore need to return this joined set.  A bad 
algorithm would be the following</p>
<pre class="prettyprint lang-javascript">
var userObj = getUser(req.user)
var posts = []
posts.addAll(getPostsByAuthor(userObj.username))
userObj.following.forEach(function(user) {
    posts.addAll(getPostsByAuthor(user))
})
</pre>
<p>(Note there is no addAll() function.)  This is bad because it adds all posts for all time
to the result set (posts) and additionally makes multiple requests to the database.
Instead we want one query to the database that retrieves posts for all users and only those
posts that are recent.  I.e., we would prefer something like</p>
<pre class="prettyprint lang-javascript">
var userObj = getUser(req.user)
var usersToQuery = [ userObj.username ]
usersToQuery.addAll(userObj.following)
var posts = getPostsByAuthors({ authors: usersToQuery, limit: 10 })
</pre>
<p>where the query will preferentially grab the 10 most recent posts by any of the users in the array.
In this way the client will make one request to get the user's feed and it will be relatively small in size.
To retrieve the next set of posts after the initial 10, we would implement pagination on the query.
</p>

<h3>Uploading Pictures</h3>

<p>After you have all other endpoints functional, it is time to implement
the uploading of images.  The profile.picture and post.img fields are both urls to images stored
on our backend.  Note that we can potentially consume a lot of disk space if we're not careful
about limiting user uploads etc.  Additionally, local storage is not persistent to dyno reboots, i.e., 
after you repush your code, your Heroku dyno will reboot and any locally uplaoded files 
will not be available on the new dyno.  Later we'll push storage off of our Heroku app.</p>

<p>Multer is a node.js middleware for handling <code>multipart/form-data</code>, which is exactly what we have for uploading files: <code>npm install multer --save</code>.  Here is
the work horse already implemented for you.  Download <code>upload.js</code> and use it in your app.</p>

<center><a target="_blank" href="data/upload.js">Get upload.js here</a></center>

<p>Upload.js provides us one export <code>uploadFile</code> which provides to us middleware for use in our routes to upload the profile picture and upload a post.</p>
<pre class="prettyprint lang-javascript">
app.post('/post'   , isLoggedIn, uploadFile('post')  , addPost)
app.put ('/picture', isLoggedIn, uploadFile('avatar'), setProfilePicture)

// the middleware consumes the file (if it exists) and sets
//   req.filepath = local path to file
//   req.fileurl  = full url to file

function setProfilePicture(req, res) {
    var userObj = getUser(req.username)
    userObj.picture = req.fileurl
    res.send({ 
        'status': 'OK', 
        'username': userObj.username, 
        'picture': userObj.picture 
    })
})
</pre>
<p>Test locally before uploading to Heroku so you can see where the files are being uploaded and moved to. 
Again, each time your Heroku app reboots, it will start with a fresh installation which means none of the uploads
will be persistent.</p>

<h3>Initialization</h3>

<p>We start with an empty database!  But to visualize your site we would like some sample 
data and users.  Add your dummy server test user to your site.  This is the one with a username like "sep1test" -- use the 
same password as well.  Next add some sample content.  For example, you can pull posts from the dummy server and
post them to your server.  I wrote a script to do this for you.  Download <a target="_blank" href="data/initDatabase.js">initDatabase.js</a>
and place in a node package that has <code>request</code> already installed (e.g., your backend!).
Create a file <code>cred.json</code> with something like the following:
</p>
<pre class="prettyprint lang-javascript">
{
     "dummy_username": "sep1test",
     "dummy_password": "native-web-tester",
     "dummy_url": "https://webdev-dummy.herokuapp.com",
     "site_username": "sep1test",
     "site_password": "native-web-tester",
     "site_url": "https://ricebookserver.herokuapp.com"
}
</pre>
<p>make sure you use double-quotes everywhere.  Then run the program:</p>
<pre>
node initDatabase.js 
</pre>
<p>It will login to the dummy server, pull posts and push them to your server.  You can run this for your user, your test user, and for my test user (credentials above).  Note that it does not do comments -- so add some of your own manually or modify the script to do it.  The script literally pushes what it reads, so if your post schema is different then it may not behave well.  You are encouraged to examine the code.</p>

<!-- *********************************************************** -->
<!-- *********************************************************** -->
<!-- *********************************************************** -->
<h1>Requirements</h1>

<p>Submit again your <code>README.json</code> that has contents similar to this</p>
<pre style="border: 1px solid black; padding: 0.5em;">
{ 
     "netid": "sep1",
  "frontend": "https://ricebookapp.herokuapp.com",
   "backend": "https://ricebookserver.herokuapp.com"
}
</pre>
<p>replace "ricebookapp" and "ricebookserver" with the names of your frontend and backend applications, and replace "sep1" with your netID.</p>

<p>Verify that your deployed frontend application works 100% with your backend server.  
Students will use your frontend app and it's interoperability with the backend server when writing user feedback for you.
</p>

<h3>Integrated Web Application</h3>
<ul>
    <li>A file <code>README.json</code> that has your frontend and backend URLs along with netid</li>
    <li>Your backend implements all endpoints, except the <code>/locations</code> endpoints, in the 
<a target="_blank" href="data/api.html">API list</a>.</li>
    <li>Register new users and provide each user a unique salt</li>
    <li>There are at least three collections in the database as described above</li>
    <li>All data (except uploads) is persistent to server reboot</li>
    <li>Users can update their profile picture and create posts with images</li>
    <li>At least 10 preloaded posts exist in the database</li>    
    <li>At least 3 comments preloaded into the database, two comments on one post, and one comment on a different post</li>
    <li>Your test user account can log in with the three-word dummy server password previously supplied</li>
    <li>Run your Protractor end-to-end tests against your live Heroku-hosted webapp.  It should hit your live Heroku-hosted backend.  Include the updated protractor.conf.js and junitresults.xml in your submission.</li>
</ul>

<h2>What to submit</h2>

<p>Your submission directory should look something like this</p>

<div class="ui list"><div class="item">
    <i class="folder icon"></i>
    <div class="content">
        <div class="header">hw-integrated</div>
        <div class="list">

            <div class="item">
                <i class="file text outline icon"></i>
                <div class="content"><div class="description">README.json</div></div>
            </div>

            <div class="item">
                <i class="folder icon"></i>
                <div class="content"><div class="header">e2e</div>
                    <div class="list">
                        <div class="item">
                            <i class="file outline icon"></i>
                            <div class="content"><div class="description">junitresults.xml</div></div>
                        </div>  
                        <div class="item">
                            <i class="file outline icon"></i>
                            <div class="content"><div class="description">protractor.conf.js</div></div>
                        </div>  
                    </div>
                </div>                          
            </div>  

            <div class="item">
                <i class="folder icon"></i>
                <div class="content">
                    <div class="header">RiceBookServer</div>
                    <div class="list">
                        <div class="item">
                            <i class="folder icon"></i>
                            <div class="content">
                                <div class="header">app_server</div>
                                <div class="list">

                                    <div class="item">
                                        <i class="file text outline icon"></i>
                                        <div class="content"><div class="description">auth.js</div></div>
                                    </div>  
                                    <div class="item">
                                        <i class="file text outline icon"></i>
                                        <div class="content"><div class="description">db.js</div></div>
                                    </div>  
                                    <div class="item">
                                        <i class="file text outline icon"></i>
                                        <div class="content"><div class="description">following.js</div></div>
                                    </div> 
                                    <div class="item">
                                        <i class="file text outline icon"></i>
                                        <div class="content"><div class="description">model.js  [optional]</div></div>
                                    </div> 
                                    <div class="item">
                                        <i class="file text outline icon"></i>
                                        <div class="content"><div class="description">posts.js</div></div>
                                    </div>  
                                    <div class="item">
                                        <i class="file text outline icon"></i>
                                        <div class="content"><div class="description">posts.spec.js</div></div>
                                    </div>  
                                    <div class="item">
                                        <i class="file text outline icon"></i>
                                        <div class="content"><div class="description">users.js</div></div>
                                    </div>  

                                </div>
                            </div>
                        </div>      

                        <div class="item">
                            <i class="file text outline icon"></i>
                            <div class="content"><div class="description">index.js</div></div>
                        </div>  
                        <div class="item">
                            <i class="file text outline icon"></i>
                            <div class="content"><div class="description">package.json</div></div>
                        </div>  
                        <div class="item">
                            <i class="file outline icon"></i>
                            <div class="content"><div class="description">Procfile</div></div>
                        </div>
                        <div class="item">
                            <i class="folder icon"></i>
                            <div class="content"><div class="header">test-results</div>
                                <div class="list">
                                    <div class="item">
                                        <i class="file outline icon"></i>
                                        <div class="content"><div class="description">TEST-ValidatePostFunctionality.xml</div></div>
                                    </div>
                                </div>
                            </div>
                        </div>  
                    </div>                  
                </div>
            </div>      
        </div>
    </div>
</div>

<!-- ******************************** -->



<hr>
</div>


