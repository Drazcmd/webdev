<H1>This is in progress...</H1>

<p>
In this assignment you will deliver your multi-user web application.
</p>



<h2>Implementing the Backend Part II</h2>

<p>We now implement the remaining endpoints in the backend:</p>

<ul>
<li><code>PUT /posts/:id</code></li>
  <li><code>GET /statuses/:users</code></li>
  <li><code>GET /status</code></li>
  <li><code>PUT /status</code></li>
  <li><code>GET /following/:user</code></li>
  <li><code>PUT /following/:user</code></li>
  <li><code>DELETE /following/:user</code></li>
  <li><code>GET /email/:user</code></li>
  <li><code>PUT /email</code></li>
  <li><code>GET /zipcode/:user</code></li>
  <li><code>PUT /zipcode</code></li>
  <li><code>GET /picture/:user</code></li>
  <li><code>PUT /picture</code></li>
  <li><code>PUT /password</code></li>
</ul>

<!-- ********************************************************************** -->
<!-- ********************************************************************** -->

<h2>Database Setup</h2>

<p>We need a database to store user information.  Because we are developing a MEAN stack,
we will use MongoDB for our document store.  Heroku provides an easy prescription for 
setting up a mongolab mongoDB for your backend app.  See a 
<a href="https://piazza.com/class/ibpbmkjtg5e3m8?cid=219" target="_blank">piazza post</a>
for instructions on setting up a mongolab mongoDB directly.  To connect to your mongoDB
from your locally running application, you will need the mongodb url.  If you setup 
your db from Heroku you can get the url from the Heroku configuration
</p>
<pre class="prettyprint lang-bash">
heroku config | grep MONGO
</pre>
<p>if you setup through mongolab, then they provided you a URL.  You can if you want
to hardcode the URL in your code.  However, this breaks separations of concerns: configuration should not be in code.
Instead we want to use environment variables.  To set it on heroku
<pre class="prettyprint lang-bash">
heroku config:set MONGOLAB_URI=&lt;the url from mongolab&gt;
</pre>
<p>When running locally you can store your environment variables in a local file and then load them in node.
Here are two different ways of doing it.</p>
<pre class="prettyprint lang-javascript">
// this is .env
MONGO_URL="mongodb://ian:sekret@widmore.mongohq.com:27017/dev_local"
REDIS_KEY="1234"

// runs these in terminal
# npm install dotenv --save-dev
# echo .env >> .gitignore

// add this to index.js
if (process.env.NODE_ENV !== "production") {
    require('dotenv').load()
}
</pre>
or
<pre class="prettyprint lang-javascript">
// this is .env.json
{
  "MONGO_URL": "mongodb://ian:sekret@widmore.mongohq.com:27017/dev_local",
  "REDIS_KEY": "1234"
}

// runs these in terminal
# npm install dot-env --save-dev
# echo .env.json >> .gitignore

// add this to index.js
if (process.env.NODE_ENV !== "production") {
    require('dot-env')
}
</pre>
<p>So either store your environment in a shell file or in a json file -- your pick.
In both cases we save the loading module in our dev dependencies (so they don't show up on Heroku)
and ignore the environment file (so it doesn't show up on Heroku).  Put the loading logic
in your <code>index.js</code> file so it will be loaded first on startup.
</p>

<h3>Database Collections</h3>

<p>In the databse we will have at least three collections: users, posts, profiles. 
If we were using a RDBMS or ODM (e.g., mongoose) then these are what the schemas might look like
</p>
<pre class="prettyprint lang-javascript">
users {
    username: String,
    salt: String,
    hash: String
}

profiles {
    username: String,
    status: String,
    following: [ String ],
    email: String,
    zipcode: String,
    picture: String
}

posts {
    id: Number,
    author: String,
    body: String,
    date: Date,
    img: String, 
    comments: [{
        commentId: Number,
        author: String,
        body: String,
        date: Date
    }]
}
</pre>
<p>If you use mongoose, then you would call these schemas by their singular name: user, profile, post. 
I would therefore have in my <code>model.js</code> file</p>
<pre class="prettyprint lang-javascript">
// this is model.js
var mongoose = require('mongoose')

var userSchema = new mongoose.Schema({
    ...
})

exports.User = mongoose.model('users', userSchema)
</pre>
<p>and then in auth.js I would have</p>
<pre class="prettyprint lang-javascript">
// this is in auth.js
var models = require('./model.js')

models.User.find({ username: "sep1" }).exec(function(err, users) {
    ...
})
</pre>
<p>If you're not using mongoose (which is 100% okay) then you'd have something like this</p>
<pre class="prettyprint lang-javascript">
// this is in auth.js
db.collection('users').find({ username: "sep1" }).toArray(function(err, users) {
    ...
})
</pre>
<p>and there may or may not be a <code>model.js</code> file depending on where you put your logic (remember divide and conquer).</p>

<!-- ********************************************************************** -->
<!-- ********************************************************************** -->

<h2>Database Integration</h2>

<p>Implement the logic to query the database for the <code>GET</code> endpoints, and write to the database for the <code>PUT</code> and <code>POST</code> endpoints.
The default implementation of mongoDB collections have an <code>_id</code> field.  The _id is <u>automatically</u> populated
for you during inserts.  
<pre>
_id: ObjectId("5099803df3f4948bd2f98391")
</pre>
<p>you can use this instead of a numeric id supplied by your server.  I.e., just omit "id" from your schema and perform
queries on _id instead.  That means a request for a specific post might be</p>
<pre>
GET /posts/5099803df3f4948bd2f98391
</pre>
<p>instead of <code>GET /posts/1234</code> which is perfectly fine.  </p>
<p>
For the commentId you get to choose what to do.  A "global" value probably is not a good idea because
it may collide across different servers.  Instead you might consider something unique, such as the hash of the author &amp; timestamp which assumes that an individual user will only be connected to one server and making one post at a time -- which I think is a reasonable assumption to make.  The commentId therefore is a String not a number.  Again, it doesn't matter what it is, it is just for us to use when looking up and identifying a particular comment.</p>


<h2>User Profile</h2>

  <p>
  A new user will have a blank profile picture (you could supply some default pic if you like) and should have some default status message.
  </p>

<h2>Uploading Pictures</h2>

<p>After you have all other endpoints functional, it is time to implement
the uploading of images.  The profile.picture and post.img fields are both urls to images stored
on our backend.  Note that we can potentially consume a lot of disk space if we're not careful
about limiting user uploads etc.  Additionally, local storage is not persistent to dyno reboots, i.e., 
after you repush your code, your Heroku dyno will reboot and any locally uplaoded files 
will not be available on the new dyno.  Later we'll push storage off of our Heroku app.</p>

<p>Multer is a node.js middleware for handling <code>multipart/form-data</code>, which is exactly what we have for uploading files: <code>npm install multer --save</code>.  Here is
the work horse already implemented for you.  Download <code>upload.js</code> and use it in your app.</p>

<center><a target="_blank" href="data/upload.js">Get upload.js here</a></center>

<p>Upload.js provides us one export <code>uploadFile</code> which provides to us middleware for use in our routes to upload the profile picture and upload a post.</p>
<pre class="prettyprint lang-javascript">
app.post('/post'   , isLoggedIn, uploadFile('post')  , addPost)
app.put ('/picture', isLoggedIn, uploadFile('avatar'), setProfilePicture)

// the middleware consumes the file (if it exists) and sets
//   req.filepath = local path to file
//   req.fileurl  = full url to file

function setProfilePicture(req, res) {
    var userObj = getUser(req.username)
    userObj.picture = req.fileurl
    res.send({ 
        'status': 'OK', 
        'username': userObj.username, 
        'picture': userObj.picture 
    })
})
</pre>
<p>Test locally before uploading to Heroku so you can see where the files are being uploaded and moved to. 
Again, each time your Heroku app reboots, it will start with a fresh installation which means none of the uploads
will be persistent.</p>

<h2>A User's Feed</h2>

<p>Each logged in user has a feed which is the collection of their posts and their followers posts.  
When the user requests <code>GET /posts</code> we therefore need to return this joined set.  A poor 
algorithm would be the following</p>
<pre class="prettyprint lang-javascript">
var userObj = getUser(req.user)
var posts = []
posts.addAll(getPostsByAuthor(userObj.username))
userObj.following.forEach(function(user) {
    posts.addAll(getPostsByAuthor(user))
})
</pre>
<p>(Note there is no addAll() function.)  This is bad because it adds all posts for all time
to the result set (posts) and additionally makes multiple requests to the database.
Instead we want one query to the database that retrieves posts for all users and only those
posts that are recent.  I.e., we would prefer something like</p>
<pre class="prettyprint lang-javascript">
var userObj = getUser(req.user)
var usersToQuery = [ userObj.username ]
usersToQuery.addAll(userObj.following)
var posts = getPostsByAuthors({ authors: usersToQuery, limit: 10 })
</pre>
<p>where the query will preferentially grab the 10 most recent posts by all of the users in the array.
In this way the client will make one request to get the user's feed and it will be relatively small in size.
To retrieve the next set of posts after the initial 10, we would implement pagination on the query.
</p>
<p>We currently have the posts in memory.  So devise a simple algorithm that would provide the desired functionality.
You should be able to write it in one (yes one) statement that is composed of chained functional operations on the posts array.</p>

<h3>Initializing the Database</h3>

For example, you can pull posts from the dummy server and
post them to your server.  I wrote a script to do this for you.  
Download <a target="_blank" href="data/initDatabase.js">initDatabase.js</a>
and place in a node package that has <code>request</code> already installed (e.g., your backend!).
Create a file <code>cred.json</code> with something like the following:
</p>
<pre class="prettyprint lang-javascript">
{
     "dummy_username": "sep1test",
     "dummy_password": "native-web-tester",
     "dummy_url": "https://webdev-dummy.herokuapp.com",
     "site_username": "sep1test",
     "site_password": "native-web-tester",
     "site_url": "https://ricebookserver.herokuapp.com"
}
</pre>
<p>make sure you use double-quotes everywhere.  Then run the program:</p>
<pre class="prettyprint lang-bash">
node initDatabase.js 
</pre>
<p>It will login to the dummy server, pull posts and push them to your server.  You can run this for your user, your test user, and for my test user (credentials above).  Note that it does not do comments -- so modify the script to do it.  The script literally pushes what it reads, so if your post schema is different then it may not behave well.  You are encouraged to examine the code.</p>




<H1>This is in progress...</H1>

add option for third party OAuth, link accounts delink accounts

redis caching store for session information




<h3>Geolocation</h3>

<p>A user will register with their zipcode.  MongoDB supports searching by latitude and longitude for instance to 
find all stores close to a particular location.  This is a powerful built-in and demonstrates what MongoDB was
initially designed for.  </p>

<ul>
	<li>Your backend implements all endpoints, except the <code>/locations</code> endpoints, in the <a target="_blank" href="data/api.html">API list</a>.</li>
    <li>There are at least three collections in the database as described above</li>
    <li>All data (except uploads) is persistent to server reboot</li>
    <li>Users can update their profile picture and create posts with images</li>
    All data (except uploads) is persistent to server reboot</li>
    <li>Users can update their profile picture and create posts with images</li>
    <li>Run your Protractor end-to-end tests against your live Heroku-hosted webapp.  It should hit your live Heroku-hosted backend.  Include the updated protractor.conf.js and junitresults.xml in your submission.</li>
</ul>




<div class="ui list"><div class="item">
    <i class="folder icon"></i>
    <div class="content">
        <div class="header">hw-integrated</div>
        <div class="list">

            <div class="item">
                <i class="file text outline icon"></i>
                <div class="content"><div class="description">README.json</div></div>
            </div>

            <div class="item">
                <i class="folder icon"></i>
                <div class="content"><div class="header">e2e</div>
                    <div class="list">
                        <div class="item">
                            <i class="file outline icon"></i>
                            <div class="content"><div class="description">junitresults.xml</div></div>
                        </div>  
                        <div class="item">
                            <i class="file outline icon"></i>
                            <div class="content"><div class="description">protractor.conf.js</div></div>
                        </div>  
                    </div>
                </div>                          
            </div>  

            <div class="item">
                <i class="folder icon"></i>
                <div class="content">
                    <div class="header">RiceBookServer</div>
                    <div class="list">
                        <div class="item">
                            <i class="folder icon"></i>
                            <div class="content">
                                <div class="header">app_server</div>
                                <div class="list">

                                    <div class="item">
                                        <i class="file text outline icon"></i>
                                        <div class="content"><div class="description">auth.js</div></div>
                                    </div>  
                                    <div class="item">
                                        <i class="file text outline icon"></i>
                                        <div class="content"><div class="description">db.js</div></div>
                                    </div>  
                                    <div class="item">
                                        <i class="file text outline icon"></i>
                                        <div class="content"><div class="description">following.js</div></div>
                                    </div> 
                                    <div class="item">
                                        <i class="file text outline icon"></i>
                                        <div class="content"><div class="description">model.js  [optional]</div></div>
                                    </div> 
                                    <div class="item">
                                        <i class="file text outline icon"></i>
                                        <div class="content"><div class="description">posts.js</div></div>
                                    </div>  
                                    <div class="item">
                                        <i class="file text outline icon"></i>
                                        <div class="content"><div class="description">posts.spec.js</div></div>
                                    </div>  
                                    <div class="item">
                                        <i class="file text outline icon"></i>
                                        <div class="content"><div class="description">users.js</div></div>
                                    </div>  

                                </div>
                            </div>
                        </div>      

                        <div class="item">
                            <i class="file text outline icon"></i>
                            <div class="content"><div class="description">index.js</div></div>
                        </div>  
                        <div class="item">
                            <i class="file text outline icon"></i>
                            <div class="content"><div class="description">package.json</div></div>
                        </div>  
                        <div class="item">
                            <i class="file outline icon"></i>
                            <div class="content"><div class="description">Procfile</div></div>
                        </div>
                        <div class="item">
                            <i class="folder icon"></i>
                            <div class="content"><div class="header">test-results</div>
                                <div class="list">
                                    <div class="item">
                                        <i class="file outline icon"></i>
                                        <div class="content"><div class="description">TEST-ValidatePostFunctionality.xml</div></div>
                                    </div>
                                </div>
                            </div>
                        </div>  
                    </div>                  
                </div>
            </div>      
        </div>
    </div>
</div>
